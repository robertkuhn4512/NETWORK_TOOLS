name: network_tools

volumes:
  postgres_certs:
  postgres_vault_rendered:

services:
  # From the project root (~/NETWORK_TOOLS) to start all containers
  # docker compose -f docker-compose.prod.yml up -d
  #
  # Rebuild command if needed
  # docker compose -f docker-compose.prod.yml up -d --build
  #
  # If you only want to start the Vault service (named vault_production_node)
  # docker compose -f docker-compose.prod.yml up -d vault_production_node
  #
  # Monitor the log file while the container is running (It must be brought up and running in order to populate the log file)
  # docker compose -p network_tools -f docker-compose.prod.yml logs --tail 200 -f --timestamps vault_production_node
  #
  #
  vault_production_node:
    #build:
    #  context: backend/app/security/configuration_files/vault
    #  dockerfile: Dockerfile
    image: hashicorp/vault:1.21.1
    hostname: vault_production_node
    container_name: vault_production_node
    env_file:
      - .env      # Populate any important production environment variables here.
                  # See the file environment_variable_guide.md for information on what variables to populate
    # Rootless: publish ports instead of host networking
    ports:
      - "8200:8200"
      - "8201:8201"
    restart: unless-stopped
    volumes:
      - ./backend/app/security/configuration_files/vault/config/vault_configuration_primary_node.hcl:/vault/config/config.hcl:ro

      # TLS material (read-only)
      - ./backend/app/security/configuration_files/vault/certs/cert.crt:/vault/certs/cert.crt:ro
      - ./backend/app/security/configuration_files/vault/certs/cert.key:/vault/certs/cert.key:ro

      # Data/logs (must be writable by the container user)
      - ./container_data/vault/data:/vault/data
      - ./container_data/vault/data/logs:/vault/logs
    environment:
      VAULT_DISABLE_MLOCK: "true"
      VAULT_UI: "true"
      VAULT_CACERT: "/vault/certs/cert.crt"
      #VAULT_ADDR: "https://vault_production_node:8200"                                     # For dev container use (Hash / remove / just use the value below and change the value below in the .env file)
                                                                                            # This entry refers to the containers name. Which because of docker is in a hosts entry
                                                                                            # So reachability internally will work with this. Externally you would need to add an antry
                                                                                            # for it on your dev machine if it's separate from the machine hosting the container.
      VAULT_ADDR: "https://${PRIMARY_VAULT_SERVER_FQDN_FULL}:8200"                          # For production use with a valid FQDN (Hash the above, unhash this and rebuild)
                                                                                            # This should be populated in the environment file SERVER_1_FQDN_FULL="Your domain name here"
      VAULT_API_ADDR: "https://${PRIMARY_VAULT_SERVER_FQDN_FULL}:8200"
      VAULT_CLUSTER_ADDR: "https://${PRIMARY_VAULT_SERVER_FQDN_FULL}:8201"
      VAULT_LOG_LEVEL: "debug"                                                              # Used for debugging vault while you are testing. Comment out and rebuild with
                                                                                            # VAULT_LOG_LEVEL: "info" for production use
      #VAULT_LOG_LEVEL: "info"
      VAULT_RAFT_NODE_ID: "Node1"                                                           # If you ever change this and reboot a node in an existing cluster you will have issues
                                                                                            # So it's better to pick a name and keep it
    entrypoint: ["/bin/sh","-lc","exec vault server -config=/vault/config/config.hcl"]

  # docker compose -f docker-compose.prod.yml up -d vault_agent_postgres_pgadmin

  vault_agent_postgres_pgadmin:
    image: hashicorp/vault:1.21.1
    container_name: vault_agent_postgres_pgadmin
    restart: unless-stopped

    depends_on:
      - vault_production_node

    entrypoint: [ "/bin/sh","-lc","exec vault agent -config=/vault/agent/agent.hcl" ]

    volumes:
      # Trust bundle for Vault TLS (prefer CA if available)
      - ./backend/app/security/configuration_files/vault/certs/ca.crt:/vault/ca/ca.crt:ro

      # Agent config + templates
      - ./backend/app/postgres/vault_agent/agent.hcl:/vault/agent/agent.hcl:ro
      - ./backend/app/postgres/vault_agent/templates:/vault/templates:ro

      # Host-exported AppRole material
      - ./container_data/vault/approle/postgres_pgadmin_agent:/vault/approle:ro

      # Render target (shared)
      - postgres_vault_rendered:/vault/rendered

    healthcheck:
      test: [ "CMD-SHELL", "test -s /vault/rendered/postgres_password && test -s /vault/rendered/pgadmin_password" ]
      interval: 5s
      timeout: 3s
      retries: 30

  # docker compose -f docker-compose.prod.yml up -d postgres_certs_init

  postgres_certs_init:
    image: postgres:18.1
    container_name: postgres_certs_init
    user: "0:0"
    restart: "no"
    volumes:
      - ./backend/app/postgres/certs:/src:ro
      - postgres_certs:/dest
    entrypoint:
      - /bin/sh
      - -lc
      - |
        set -e
        mkdir -p /dest
        cp -f /src/cert.crt /dest/server.crt
        cp -f /src/cert.key /dest/server.key
        cp -f /src/ca.crt   /dest/ca.crt
        chmod 600 /dest/server.key
        chmod 644 /dest/server.crt /dest/ca.crt
        chown -R 999:999 /dest || true
        ls -l /dest



  # docker compose -f docker-compose.prod.yml up -d postgres_primary

  postgres_primary:
    image: postgres:18.1
    container_name: postgres_primary
    restart: unless-stopped
    env_file:
      - .env

    depends_on:
      postgres_certs_init:
        condition: service_completed_successfully
      vault_agent_postgres_pgadmin:
        condition: service_healthy

    environment:
      POSTGRES_DB_FILE: "/run/vault/postgres_db"
      POSTGRES_USER_FILE: "/run/vault/postgres_user"
      POSTGRES_PASSWORD_FILE: "/run/vault/postgres_password"
      PGDATA: "${PGDATA:-/var/lib/postgres/data/pgdata}"

    volumes:
      - ./container_data/postgres/data:/var/lib/postgres/data
      - ./backend/app/postgres/config/postgres.conf:/etc/postgres/postgres.conf:ro
      - ./backend/app/postgres/config/pg_hba.conf:/etc/postgres/pg_hba.conf:ro
      - postgres_certs:/etc/postgres/certs:ro

      # rendered secrets from vault agent
      - postgres_vault_rendered:/run/vault:ro

    command: >
      postgres
      -c config_file=/etc/postgres/postgres.conf
      -c hba_file=/etc/postgres/pg_hba.conf

    ports:
      - "5432:5432"

  # docker compose -f docker-compose.prod.yml up -d pgadmin

  pgadmin:
    image: dpage/pgadmin4:9.11
    container_name: pgadmin
    restart: unless-stopped

    depends_on:
      vault_agent_postgres_pgadmin:
        condition: service_healthy
      postgres_primary:
        condition: service_started

    env_file:
      - .env

    environment:
      PGDATA: "/var/lib/postgres/data/pgdata"
      PGADMIN_DEFAULT_EMAIL: "${PGADMIN_DEFAULT_EMAIL}"
      PGADMIN_DEFAULT_PASSWORD_FILE: "/run/vault/pgadmin_password"

    volumes:
      - postgres_vault_rendered:/run/vault:ro

    ports:
      - "8081:80"